В целом суть сводится к двум действиям:
1. Создание своего класса, который наследуется от ClassLoader и переопределение в нем нужных методов. В моем случае это класс MyClassLoader и метод loadClass.
2. Определение памяти, выделенной под загруженный класс. В случае, если выделенная память превышает допустимое значение - на основе класса не будет создан объект и программа кинет предупреждение в консоль.
Теперь чуть подробнее по каждому пункту.
-При переопределении метода loadClass мы используем HashMap, в котором храним 2 имени файла. одно имя - путь файла в нашей файловой системе c расширением .class (Например, D:/JavaStuff/ClassesToLoad/MyClass.class), второе - бинарное имя файла, т.е относительно нашего рабочего проекта (в моем случае - com.joko.tests.classLoader.MyClass). В созданный map можно поместить все нужные для загрузки файлы, которые будут использовать наш собственный ClassLoader. 2 имени файла нужны потому, что при загрузке класса средствами стандартного classLoader'а (метод defineClass) - используется бинарное имя, а при загрузке из файловой системы в FileInputStream - имя в файловой системе. 

- Теперь по поводу определения выделенной памяти. Я использовал средства Instrumentation, в котором есть метод getObjectSize. Но для его корректной работы необходимо сделать несколько шагов:
1. Создать класс, который будет содержать в себе объект из Instrumentation, метод premain(String args, Instrumentation inst) и собственно наш метод getObjectSize
2. Запаковать созданный класс в .jar и создать для него файл Manifest, в котором указать имя класса, содержащего premain (я залил свой в папку с остальными классами)
3. Указать для VM параметр -javaagent:"D:\JavaStuff\ObjectSize.jar", где в кавычках указано расположение созданной вами jar.

По сути это запускает агент, который инициализирует нужный нам Instrument еще до запуска функции main, используя функцию premain. После чего мы можем свободно пользоваться его средствами.